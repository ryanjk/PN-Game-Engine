#version 330

in VS_OUT {
	vec3 position;
	vec3 normal;
} fs_in;

uniform vec4 ambient;
uniform vec4 diffuse;
uniform vec4 specular;
uniform float gloss;

uniform vec3 lightPosition;

uniform vec3 cameraPosition;

out vec4 colour;

const int POINT_LIGHT = 0;
const int DIRECTIONAL_LIGHT = 1;
const int SPOTLIGHT = 2;

struct Light {
	vec3 position;
	vec3 direction;
	vec3 colour;
	int type;
	float intensity;
	float innerRadians;
	float outerRadians;
	float maxRadius;
};

const int MAX_LIGHTS = 8;

uniform int num_lights;
uniform Light lightUni[MAX_LIGHTS];

// used for spotlight to shade when point is between the inner and outer angle boundaries
float interpolate(float x, float a, float b) {
	return (x * (1/(b - a))) - (a / (b - a));
}

vec4 shadePoint(vec3 position, vec3 normal, Light light) {
	
	// Calculate maximum colour for diffuse and specular
	vec4 diffuseColour = vec4(light.colour, 1.0) * diffuse;
	vec4 specularColour = vec4(light.colour, 1.0) * specular;
	
	// Unit normal at surface
	vec3 unit_normal = normalize(normal);
	
	// if light is a directional light
	if (light.type == DIRECTIONAL_LIGHT) {

		vec3 lightToSurface = normalize(light.direction);
		
		// Reflection vector for specular scaling
		vec3 R = reflect(-1 * lightToSurface, unit_normal);
		
		vec4 shadedColour = vec4(0.0, 0.0, 0.0, 1.0);
		
		shadedColour += diffuseColour * (max(0, dot(unit_normal, lightToSurface))) * light.intensity;
		
		if (gloss > 0) {
			shadedColour += specularColour * pow(max(0, dot(R, normalize(cameraPosition - position))), gloss) * light.intensity;
		}
		
		return shadedColour;
	}
	
	// if light is a point light
	else if (light.type == POINT_LIGHT) {
		
		// Unit vector that points from the light to the surface
		vec3 surfaceToLight = normalize(light.position - position);
		
		// Reflection vector for specular scaling
		vec3 R = reflect(-1 * surfaceToLight, unit_normal);
		
		// Reduction from distance from light source
		float fallOff = (1 / pow(length(light.position - position), 2));
		
		vec4 shadedColour = vec4(0.0, 0.0, 0.0, 1.0);
		
		shadedColour += diffuseColour * (max(0, dot(unit_normal, surfaceToLight))) * fallOff * light.intensity;
		
		if (gloss > 0) {
			shadedColour += specularColour * pow(max(0, dot(R, normalize(cameraPosition - position))), gloss) * fallOff * light.intensity;
		}
		
		return shadedColour;
	}
	
	// if light is a spot light
	else if (light.type == SPOTLIGHT) {
		
		float min = cos(light.outerRadians / 2);
		
		vec3 lightToSurface = normalize(position - light.position);
		vec3 lightDirection = normalize(light.direction);
		
		float cosAngle = dot(lightToSurface, lightDirection);
		
		// if surface is outside the range of the spotlight's outer angle, do not perform any shading
		if (cosAngle < min) {
			return vec4(0.0, 0.0, 0.0, 1.0);
		}

		float innerBoundary = cos(light.innerRadians / 2);
		
		// if surface is within the inner angle, treat it like a point light shade
		if (cosAngle >= innerBoundary) {
			// Unit vector that points from the light to the surface
			vec3 surfaceToLight = normalize(light.position - position);
			
			// Reflection vector for specular scaling
			vec3 R = reflect(-1 * surfaceToLight, unit_normal);
			
			// Reduction from distance from light source
			float fallOff = (1 / pow(length(light.position - position), 2));
			
			vec4 shadedColour = vec4(0.0, 0.0, 0.0, 1.0);
			
			shadedColour += diffuseColour * (max(0, dot(unit_normal, surfaceToLight))) * fallOff * light.intensity;
			
			if (gloss > 0) {
				shadedColour += specularColour * pow(max(0, dot(R, normalize(cameraPosition - position))), gloss) * fallOff * light.intensity;
			}
			
			return shadedColour;
		}
		
		// treat like a point light but with diminished intensity
		else {
			
			float diminishedIntensity = light.intensity * interpolate(cosAngle, min, innerBoundary);
		
			// Unit vector that points from the light to the surface
			vec3 surfaceToLight = normalize(light.position - position);
			
			// Reflection vector for specular scaling
			vec3 R = reflect(-1 * surfaceToLight, unit_normal);
			
			// Reduction from distance from light source
			float fallOff = (1 / pow(length(light.position - position), 2));
			
			vec4 shadedColour = vec4(0.0, 0.0, 0.0, 1.0);
			
			shadedColour += diffuseColour * (max(0, dot(unit_normal, surfaceToLight))) * fallOff * diminishedIntensity;
			
			if (gloss > 0) {
				shadedColour += specularColour * pow(max(0, dot(R, normalize(cameraPosition - position))), gloss) * fallOff * diminishedIntensity;
			}
			
			return shadedColour;

		}

	}

}



void main() {

	vec4 ambientLightColour = vec4(1.0, 1.0, 1.0, 1.0);
	vec4 ambientColour = ambientLightColour * ambient;

	vec4 finalColour = vec4(0.0, 0.0, 0.0, 1.0);
	
	for (int i = 0; i < num_lights; i++) {
		finalColour += shadePoint(fs_in.position, fs_in.normal, lightUni[i]);
	}
	
	vec4 finalAmbient = ambientColour;
	colour = finalAmbient + finalColour;
}